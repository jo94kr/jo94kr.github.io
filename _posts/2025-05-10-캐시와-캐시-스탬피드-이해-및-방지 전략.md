---
title: 캐시와 캐시 스탬피드 이해 및 방지 전략
date: 2025-05-10 07:59:35 +0900
categories:
  - 백엔드 아키텍처
tags:
  - redis
  - 캐시스탬피드
  - 분산락
  - TTL전략
  - PER알고리즘
  - 백엔드최적화
  - Java캐시
  - 서비스장애예방
---
## 📌 문서 개요
**캐시 스탬피드(Cache Stampede)**는 다수의 요청이 동시에 캐시 미스를 일으켜, 백엔드(DB 또는 API)에 과도한 부하를 주며 서비스 장애로 이어지는 현상입니다.

이 문서에서는 **스탬피드가 발생하는 방식**과 이를 방지하기 위한 **3가지 실용적인 전략**을, Redis 기반 Java 애플리케이션을 기준으로 설명합니다.

### 이 문서를 통해 알 수 있는 내용
- 캐시의 기본 동작 원리와 장점
- 캐시 스탬피드가 발생하는 이유와 구체적인 시나리오

---

## 1. 캐시 스탬피드는 어떻게 발생하는가?

### 💥 전형적인 시나리오
1. 인기 상품 API에 분당 수천 건의 요청 발생
2. 캐시 TTL(Time To Live)을 5분으로 설정
3. 5분 후 캐시 만료 → 모든 요청이 동시에 캐시 미스
4. 백엔드(DB, API 등)에 같은 데이터를 요청하는 수천 건의 트래픽 발생
5. DB 과부하로 서비스 장애 발생

### 핵심 원인
- TTL이 고정되어 있어, 캐시 만료 시점이 집중됨
- 캐시 미스 시 다수의 요청이 동시에 백엔드로 몰림
- 요청 제어 장치 없을 경우 트래픽이 그대로 반영됨

---

## 2. 방지 전략

캐시 스탬피드를 막기 위해 다음 3가지 전략을 사용할 수 있습니다.

### 2.1. 락을 이용한 단일 갱신

> 하나의 요청만 백엔드를 호출하고, 나머지는 락 해제까지 대기하거나 캐시를 다시 확인합니다.
#### 예시 (Redisson 기반)
``` java
RLock lock = redissonClient.getLock("lock::goods::populer");
if (lock.tryLock(2, 10, TimeUnit.SECONDS)) {
    try {
        Object cached = redisTemplate.opsForValue().get(key);
        if (cached == null) {
            Object data = fetchFromDB();
            redisTemplate.opsForValue().set(key, data, Duration.ofMinutes(5));
            return data;
        }
        return cached;
    } finally {
        lock.unlock();
    }
} else {
    // 다른 요청이 갱신 중이므로 잠시 후 캐시 재확인
    Thread.sleep(100);
    return redisTemplate.opsForValue().get(key);
}

```

#### 장점
- 중복된 데이터 갱신 방지
- 고정 TTL 환경에서 안정적
#### 단점
- 락 구현 필요 (Redisson등 활용)
- 병렬 요청의 대기 시간 발생 가능

---

### 2.2. TTL 분산(Randomized TTL)

> 모든 요청이 **같은 시점에 만료되지 않도록**, TTL에 무작위 값을 추가해 만료 시점을 분산시킵니다.

#### 예시
``` java
int baseTtl = 300; // 5분
int jitter = new Random().nextInt(60); // 0~60초
redisTemplate.opsForValue().set(key, data, baseTtl + jitter, TimeUnit.SECONDS);
```

#### 장점
- 구현이 간단하고 효과적
- TTL 집중 만료로 인한 스탬피드 확률 분산
#### 단점
- TTL 예측이 어려워질 수 있음
- TTL이 너무 짧으면 캐시 효울 저하

### 2.3. **PER (Probabilistic Early Recomputation)**

> TTL이 다 되기 전에 **확률적으로 미리 캐시를 갱신**합니다. 시간이 지날수록 갱신 확률이 증가합니다.

#### 예시
``` java
public boolean shouldRefresh(long ttl, long age, double beta) {
    double probability = Math.exp(-beta * age / ttl);
    return Math.random() < probability;
}
```

- `ttl`: 캐시 TTL
- `age`: 캐시가 사용된 시간
- `beta`: 민감도 조절 값 (보통 1~2)

#### 장점
- TTL이 같더라도 갱신 시점이 다양화되어 스탬피드 완화
- 일정 확률로 미리 갱신하므로 장애 가능성 감소
#### 단점
- 수학 기반 알고리즘 구현 필요
- 상황에 따라 튜닝 필요

## 3. 마무리

캐시는 고성능 시스템 구현에 필수적인 도구이지만, TTL 설정이나 갱신 타이밍이 잘못되면 캐시 스탬피드 같은 심각한 문제가 발생할 수 있습니다.
특히 **짧은 TTL을 사용하는 API나 대용량 트래픽 환경**에서는, 단순한 캐싱만으로는 안정성을 보장하기 어렵습니다. 이때는 **캐시 미스가 집중되지 않도록 제어하는 전략**이 반드시 필요합니다.

